**数据结构 = 结构定义 + 结构操作**

---

# 顺序表

## 插入

## 删除

## 扩容

~~~c
#include<stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct Vector {
    int *data;
    int size, length;
} Vector;

Vector *init(int n) {
    Vector *vec = (Vector *)malloc(sizeof(Vector));
    vec->data = (int *)malloc(sizeof(int) * n);
    vec->size = n;
    vec->length = 0;
    return vec;
}

//扩容(倍增思想)
int expand(Vector *vec) {
    //vec->size *= 2;
    //vec->data = (int *)realloc(vec->data, sizeof(int) * vec->size);
    //return 1;
    int extr_size = vec->size;
    int *p;
    while(extr_size) {
        p = (int *)realloc(vec->data, sizeof(int) * (vec->size + extr_size));
        if(p) break;
        extr_size /= 2;
    }
    if(p == NULL) return 0;
    vec->data = p;
    vec->size += extr_size;
    return 1;
}


int insert(Vector *vec, int ind, int val) {
    if(vec == NULL) return 0;
    if(ind < 0 || ind > vec->length) return 0;
    if(vec->length == vec->size) {
        if(!expand(vec)) {
            //printf("扩容失败\n");
            return 0;
        }
        printf("expand succeddfully! szie = %d\n", vec->size);
    }
    for(int i = vec->length; i > ind; i--) {
        vec->data[i] = vec->data[i - 1];
    }
    vec->data[ind] = val;
    vec->length++;
    return 1;
}

int erase(Vector *vec, int ind) {
    if(vec == NULL) return 0;
    if(ind < 0 || ind >= vec->length) return 0;
    for(int i = ind + 1; i < vec->length; i++) {
        vec->data[i - 1] = vec->data[i];
    }
    vec->length--;
    return 1;
}

void output(Vector *vec) {
    printf("Vector(%d) = [", vec->length);
    for(int i = 0; i < vec->length; i++) {
        i && printf(", ");
        printf("%d", vec->data[i]);
    }
    printf("]\n");
    return ;
}

void clear(Vector *vec) {
    if(vec == NULL) return ;
    free(vec->data);
    free(vec);
    return ;
}

int main() {
    //随机种子
    srand(time(0));
    #define max_op 20
    Vector *vec = init(1);
    int op, ind, val;
    for(int i = 0; i < max_op; i++) {
        op = rand() % 4;
        ind = rand() % (vec->length + 3) - 1;
        val = rand() % 100;
        switch(op) {
            case 0: 
            case 1:
            case 2:{
                printf("insert %d at %d to Vector = %d\n", val, ind, insert(vec, ind, val));
            } break;
            case 3: {
                printf("erase item at %d from Vector = %d\n", ind, erase(vec, ind));
            } break;
        }
        output(vec);
        printf("\n");
    }
    clear(vec);
    return 0;
}
~~~

---

# 链表

创建，初始化，插入，删除，遍历输出，反转，清空

## 普通链表

~~~c
#include <time.h>
#include<stdio.h>
#include <stdlib.h>

typedef struct ListNode {
    int data;
    struct ListNode *next;
} ListNode;

typedef struct List {
    ListNode head;
    int length;
} List;


ListNode *getNewNode (int val) {
    ListNode *p = (ListNode *)malloc(sizeof(ListNode));
    p->data = val;
    p->next = NULL;
    return p;
}


List *getLinkList() {
    List *l = (List*)malloc(sizeof(List));
    l->head.next = NULL;
    l->length = 0;
    return l;
}


int insert(List *l, int ind, int val) {
    if(l == NULL) return 0;
    if(ind < 0 || ind > l->length) return 0;
    ListNode *p = &(l->head), *node = getNewNode(val);
    while(ind--) p = p->next;
    node->next = p->next;
    p->next = node;
    l->length++;
    return 1;
}


int erase(List *l, int ind) {
    if(ind < 0 || ind >= l->length) return 0;
    if(l == NULL) return 0;
    ListNode *p = &(l->head), *q;
    while(ind--) p = p->next;
    q = p->next;
    p->next = q->next;
    free(q);
    l->length--;
    return 1;
}


//链表反转
void reverse(List *l) {
    if(l == NULL) return ;
    ListNode *p = l->head.next, *q;
    l->head.next = NULL;
    while(p) {
        q = p->next;
        p->next = l->head.next;
        l->head.next = p;
        p = q;
    }
    return ;
}


void output(List *l) {
    printf("List(%d) = [", l->length);
    for(ListNode *p = l->head.next; p; p = p->next) {
        printf("%d->", p->data);
    }
    printf("NULL]\n");
    return ;
}


void clear_ListNode(ListNode *node) {
    if(node == NULL) return ;
    free(node);
    return ;
}

void clear_List(List *l) {
    if(l == NULL) return ;
    ListNode *p = l->head.next, *q;
    while(p) {
        q = p->next;
        clear_ListNode(p);
        p = q;
    }
    free(l);
    return ;
}


int main() {
    srand(time(0));
    #define max_op 20
    List *l = getLinkList();
    int op, ind, val;
    for(int i = 0; i < max_op; i++) {
        op = rand() % 4;
        ind = rand() % (l->length + 3) - 1;
        val = rand() % 100;
        switch(op) {
            case 0:
            case 1: {
                printf("insert %d at %d to List = %d\n", val, ind, insert(l, ind, val));
            } break;
            case 2: {
                printf("revere List:");
                reverse(l);
                output(l);
            } break;
            case 3: {
                printf("erase item at %d from List = %d\n", ind, erase(l, ind));
            } break;
        }
        output(l);
        printf("\n");
    }
    clear_List(l);
    return 0;
}
~~~

## 单向循环链表

约瑟夫问题

>   1. 定义一个遍历指针，初始指向 head，并让 head 指向空地址避免操作结束后变为野指针。
>   2. 找到遍历指针往后数的第 n 次所指向的结点。
>   3. 输出该结点的数据，更新遍历指针，然后删除该结点。
>   4. 重复操作 2 直至只剩下最后一个结点。
>   5. 输出最后一个结点并删除。

~~~c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node{
    int data;
    struct Node *next;
}Node, *LinkedList;

LinkedList insert(LinkedList head, Node *node, int index) {
    if (head == NULL) {
        if (index != 0) {
            return head;
        }
        head = node;
        head->next = head;
        return head;
    }
    if (index == 0) {
        node->next = head->next;
        head->next = node;
        return head;
    }
    Node *current_node = head->next;
    int count = 0;
    while (current_node != head && count < index - 1) {
        current_node = current_node->next;
        count++;
    }
    if (count == index - 1) {
        node->next = current_node->next;
        current_node->next = node;
    }
    if (node == head->next) {
        head = node;
    }
    return head;
}

// 请在下面实现输出函数 output_josephus

void output_josephus(LinkedList head, int m) {
    Node *current_node = head;
    head = NULL;
    while(current_node->next != current_node) {
        for(int i = 1; i < m; i++) {
            current_node = current_node->next;
        }
        printf("%d ", current_node->next->data);
        Node *delete_node = current_node->next;
        current_node->next = current_node->next->next;
        free(delete_node);
    }
    printf("%d\n", current_node->data);
    free(current_node);
}


int main() {
    LinkedList linkedlist = NULL;
    int n, m;
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++) {
        Node *node = (Node *)malloc(sizeof(Node));
        node->data = i;
        node->next = NULL;
        linkedlist = insert(linkedlist, node, i - 1);
    }
    output_josephus(linkedlist, m);
    return 0;
}
~~~

## 双向链表

## 双向循环链表

~~~c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *prior, *next;
} Node, *List;
/*
typedef struct List {
    Node *head;
    int length;
} List;
*/
List insert(List head, Node *node) {
    if(head == NULL) {
        head = node;
        head->next = head;
        head->prior = head;
        return head;
    }
    node->next = head->next;
    node->prior = head;
    head->next->prior = node;
    head->next = node;
    head = node;
    return head;
}

void output(List head, int m) {
    Node *p = head;
    int cnt = 0;
    while(p->data != m) {
        p = p->next;
    }
    //p = p->prior;
    Node *q = p;
    printf("%d", q->data);
    while(q->prior != p) {
        q = q->prior;
        printf(" %d", q->data);
    }
    printf("\n");
    return ;
}

void clear(List l) {
	Node *p = l->next, *q;
    while(p != l) {
        q = p->next;
        free(p);
        p = q;
    }
    free(l);
    return ;
}

int main() {
    List list = NULL;

    int n, m, a;
    scanf("%d", &n);

    for(int i = 0; i < n; i++) {
        scanf("%d", &a);
        Node *node = (Node *)malloc(sizeof(Node));
        node->data = a;
        node->prior = NULL;
        node->next = NULL;
        list = insert(list, node);
    }

    scanf("%d", &m);
    output(list, m);
    clear(list);
    return 0;
}
~~~



----

# 队列

## 循环队列

~~~c
#include<stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct Queue {
    int *data;
    int head, tail, size, count;
} Queue;

Queue *init(int n) {
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q->data = (int *)malloc(sizeof(int) * n);
    q->size = n, q->head = 0, q->tail = 0, q->count = 0;
    return q;
}

int empty(Queue *q) {
    return !q->count;
}

int front(Queue *q) {
    return q->data[q->head];
}

int push(Queue *q, int val) {
    if(q == NULL) return 0;
    if(q->count == q->size) return 0; 
    q->data[q->tail++] = val;
    //q->tail = (q->tail + 1) % q->size;
    if(q->tail == q->size) q->tail -= q->size;
    q->count++;
    return 1;
}

void output(Queue *q) {
    printf("Queue(%d) = [", q->count);
    for(int i= q->head, j = 0; j < q->count; j++) {
        j && printf(", ");
        printf("%d", q->data[(i + j) % (q->size)]);
    }
    printf("]\n");
    return ;
}

int pop(Queue *q) {
    if(q == NULL) return 0;
    if(empty(q)) return 0;
    q->head++;
    if(q->head == q->size) q->head -= q->size;
    q->count--;
    return 1;
}

void clear(Queue *q) {
    if(q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    Queue *queue = init(max_op);
    int op, val;
    for(int i = 0; i < max_op; i++) {
        op = rand() % 4;
        val = rand() % 100;
        switch(op) {
            case 0:
            case 1:
            case 2: {
                printf("push %d to Queue = %d\n", val, push(queue, val));
            } break;
            case 3: {
                printf("pop %d from Queue = ", front(queue));
                printf("%d\n", pop(queue));
            } break;
        }
        output(queue);
        printf("\n");
    }
    return 0;
}
~~~

## 单调队列



-----

# 栈

## 普通栈

~~~c
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

typedef struct Stack {
    int *data;
    int top, size;
} Stack;

Stack *init(int n) {
    Stack *s = (Stack *)malloc(sizeof(Stack));
    s->data = (int *)malloc(sizeof(int) * n);
    s->top = -1;
    s->size = n;
    return s;
}

int empty(Stack *s) {
    return s->top == -1;
}

int top(Stack *s) {
    return s->data[s->top];
}

int expand(Stack *s) {
    int ext_size = s->size * 2;
    int *p;
    while(ext_size) {
        p = (int *)realloc(s->data, sizeof(int) * (s->size + ext_size));
        if(p) return 0;
        ext_size /= 2;
    }
    if(p == NULL) return 0;
    s->data = p;
    s->size += ext_size;
    return 1;
}

int push(Stack *s, int val) {
    if(s == NULL) return 0;
    if(s->top + 1 == s->size){
        if(expand(s) == 0) return 0;
    }
    s->data[++(s->top)] = val;
    return 1;
}

int pop(Stack *s) {
    if(s == NULL) return 0;
    if(empty(s)) return 0;
    s->top -= 1;
    return 1;
}


void output(Stack *s) {
    printf("Stack(%d) = [", s->top + 1);
    for(int i = 0; i <= s->top; i++) {
        i && printf(", ");
        printf("%d", s->data[i]);
    }
    printf("]\n");
    return ;
}

void clear(Stack *s) {
    if(s == NULL) return ;
    free(s->data);
    free(s);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    int op, val;
    Stack *s = init(max_op);
    for(int i = 0; i < max_op; i++) {
        op =  rand() % 4;
        val = rand() % 100;
        switch(op) {
            case 0:
            case 1:
            case 2: {
              printf("push %d to Stack = %d\n", val, push(s, val));  
            } break;
            case 3: {
                printf("pop %d from Stack = ", top(s));
                printf("%d\n", pop(s));
            } break;
        }
        output(s);
        printf("\n");
    }
    clear(s);
    return 0;
}
~~~



**表达式求值**

>   1. 使用两个栈分别存储数值和运算符。
>   2. 读取表达式字符，数值存入数值栈，运算符和栈顶运算符比较优先级。
>   3. 通过运算符优先级不同选择将它压入栈或取出数值栈中两个元素进行计算，计算结果入栈。
>   4. 返回步骤 2，直至表达式全部读完。
>   5. 弹出一个运算符和两个数值进行运算，计算结果存储数值栈。
>   6. 当运算符栈不为空时，返回步骤 5，否则数值栈中剩余的最后一个元素就是表达式求值结果。



利用系统栈，即递归

~~~c
#include<stdio.h>
#include <string.h>
#include <math.h>
#define max_n 100
#include <inttypes.h>
int calc(const char *str, int l, int r) {
    int prior = 0x3f3f3f3f - 1, temp = 0, pos = -1;
    for(int i = l; i <= r; i++) {
        int cur_prior = 0x3f3f3f3f;
        switch(str[i]) {
            case '(' : 
                temp += 100;
                break;
            case ')' :
                temp -= 100;
                break;
            case '+' :
            case '-' :
                cur_prior = temp + 1;
                break;
            case '*' :
            case '/' :
                cur_prior = temp + 2;
                break;
            case '^' :
                cur_prior = temp + 3;
                break;
        }
        if(cur_prior <= prior) {
            pos = i;
            prior = cur_prior;
        }
    }
    if(pos == -1) {
        int num = 0;
        for(int i = l; i <= r; i++) {
            if(str[i] < '0' || str[i] > '9') continue;
            num = num * 10 + str[i] - '0';
        }
        return num;
    }
    int a = calc(str, l, pos - 1);
    int b = calc(str, pos + 1, r);
    switch (str[pos]) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;
        case '^': return (int)pow(a, b);
    }
    return 0;
}

int main() {
    char str[max_n + 5] = {0};
    while(scanf("%[^\n]s", str) != EOF) {
        getchar();
        printf("%d\n", calc(str, 0, strlen(str) - 1));
    }
    return 0;
}
~~~









## 单调栈



------



# 树

## 二叉树

**性质：**

>   ![img](https://static.dingtalk.com/media/lALPDgQ9rnnKQZ7NASnNBHg_1144_297.png?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%22742721380%3A742721380%22%2C%22msgId%22%3A%222301936150127%22%7D&bizType=im&open_id=742721380) 	



## 二叉树遍历

>   递归的输出

~~~c
//前序遍历
void pre_order(pNode p) {
    if(p == NULL) return ;
    printf("%c ", p->data);
    if(p->l) pre_order(p->l);
    if(p->r) pre_order(p->r);
    return ;
}
//中序遍历
void in_order(pNode p) {
    if(p == NULL) return ;
    if(p->l) in_order(p->l);
    printf("%c ", p->data);
    if(p->r) in_order(p->r);
    return ;
}
//后序遍历
void post_order(pNode p) {
    if(p->l) post_order(p->l);
    if(p->r) post_order(p->r);
    printf("%c ", p->data);
    return ;
}
~~~

## 二叉树的层次遍历

孩子入队后爹出对

~~~c
/**********************************************
将广义表转成二叉树再以层次遍历输出

**********************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct Node {
    char data;
    struct Node *l, *r;
} Node, *pNode;

typedef struct Stack {
    pNode *data;
    int top, size;
} Stack;

typedef struct Queue {
    pNode *data;
    int head, tail, size, cnt;
} Queue;


//栈的操作
void init_stack(Stack *s, int len) {
    s->data = (pNode *)malloc(sizeof(pNode) * len); //???????????????????????????????????????????????????
    s->top = -1;
    s->size = len;
    return ;
}
int empty(Stack *s) {
    return s->top == -1;
}
int push(Stack *s, pNode p) {
    if(s->top + 1 >= s->size) {
        return 0;
    }
    s->data[++(s->top)] = p;
    return 1;
}
pNode top(Stack *s) {
    if(empty(s)) return NULL;
    return s->data[s->top];
}
int pop(Stack *s){
    if(empty(s)) return 0;
    s->top--;
    return 1;
}
void clear(Stack *s) {
    if(s == NULL) return ;
    free(s->data);
    free(s);
    return ;
}

//队列操作
void init_queue(Queue *q, int len) {
    q->data = (pNode*)malloc(sizeof(pNode) * (2 * len));
    q->size = len;
    q->head = 0;
    q->tail = -1;
    q->cnt = 0;
    return ;
}
int empty_queue(Queue *q) {
    return q->tail < q-> head; //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
}
int push_queue(Queue *q, pNode p) {
    if(q->tail >= q->size) return 0;
    q->data[++(q->tail)] = p; //xxxxxxxxxxxxxxxxxxxxxxxxtailduojialexxxxxxxxxxxxxxxxxxx
    q->cnt++;
    return 1;
}
int pop_queue(Queue *q) {
    if(empty_queue(q)) return 0;
    q->head++;
    return 1;
}
void clear_queue(Queue *q) {
    if(q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}


//树的操作
Node *get_node(char c) {
    Node *node = (Node *)malloc(sizeof(Node));  //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    node->data = c;
    node->l = node->r = NULL;
    return node;
}
void clear_node(Node *node) {
    if(node == NULL) return ;
    if(node->l) clear_node(node->l);
    if(node->r) clear_node(node->r);
    free(node);
    return ;
}
pNode built_tree(char *str, int *node_num) {
    pNode temp = NULL, current_root = NULL;
    Stack *s = (Stack *)malloc(sizeof(Stack));  //?
    init_stack(s, strlen(str));
    int flag = 0;
    while(str[0]) {
        switch(str[0]) {
            case '(':
                push(s, temp);
                flag = 0;
                temp = NULL;
                break;
            case ',':
                flag = 1;
                temp = NULL;
                break;
            case ')':
                current_root = top(s);
                pop(s);
                break;
            case ' ':
                break;
            default:
                temp = get_node(str[0]);
                if(!empty(s) && flag == 0) {
                    s->data[s->top]->l = temp;    //xxxxxxxxxxxxxx
                } else if(!empty(s) && flag == 1){
                    s->data[s->top]->r = temp; //xxxxxxxxxxxx top(s)->r=.. 不对  xxxxxxxxxxxxxxx
                }
                ++(*node_num);
                break; //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
        }
        str++; //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx忘写，导致我关机两次
    }
    if(temp && !current_root) current_root = temp; //xxxx***
    clear(s); //忘写
    return current_root;
}

//✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍  层次遍历输出 ✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍
void output(pNode node, int node_num) {
    if(node_num == 0) return ;
    printf("%c", node->data);
    Queue *q = (Queue *)malloc(sizeof(Queue));
    init_queue(q, node_num);
    push_queue(q, node);
    while(!empty_queue(q)) {
        if(q->data[q->head]->l == NULL && q->data[q->head]->r == NULL) {
            pop_queue(q);
            continue;
        }
        if(q->data[q->head]->l) {
            push_queue(q, q->data[q->head]->l);
            printf(" %c", q->data[q->head]->l->data);
        }
        if(q->data[q->head]->r) {
            push_queue(q, q->data[q->head]->r);
            printf(" %c", q->data[q->head]->r->data);
        }
        pop_queue(q);
    }
    printf("\n");
    clear_queue(q);
    return ;
}

void in_order(pNode p) {
    if(p->l) in_order(p->l);
    printf("%c", p->data);
    if(p->r) in_order(p->r);
}

int main(){
    char str[100];
    scanf("%[^\n]s", str);
    int node_num = 0;
    pNode tree = built_tree(str, &node_num);
    output(tree, node_num);
    clear_node(tree);
    return 0;
}
~~~

## 二叉树加线索化

后孩子若为空就让右孩子指针域指向其后继

~~~c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define NORMAL 0
#define THREAD 1

typedef struct Node {
    int data;
    struct Node *lchild, *rchild;
    int ltag, rtag;
} Node;

Node *getNewNode(int val) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = val;
    p->lchild = p->rchild = NULL;
    p->ltag = NORMAL;
    p->rtag = NORMAL;
    return p;
}

Node *insert(Node *root, int val) {
    if (root == NULL) return getNewNode(val);
    if (root->data == val) return root;
    if (val < root->data) root->lchild = insert(root->lchild, val);
    else root->rchild = insert(root->rchild, val);
    return root;
}

void build_thread(Node *root) {
    if (root == NULL) return ;
    static Node *pre = NULL;
    build_thread(root->lchild);
    if (root->lchild == NULL) {
        root->lchild = pre;
        root->ltag = THREAD;
    }
    if (pre != NULL && pre->rchild == NULL) {
        pre->rchild = root;
        pre->rtag = THREAD;
    }
    pre = root;
    build_thread(root->rchild);
    return ;
}

Node *most_left(Node *p) {
    while (p && p->ltag == NORMAL && p->lchild != NULL) p = p->lchild;
    return p;
}

void output(Node *root) {
    Node *p = most_left(root);
    while (p) {
        printf("%d ", p->data);
        if (p->rtag == THREAD) {
            p = p->rchild;
        } else {
            p = most_left(p->rchild);
        }
    }
    return ;
}
void in_order(Node *root) {
    if (root == NULL) return ;
    if (root->ltag == NORMAL) in_order(root->lchild);
    printf("%d ", root->data);
    if (root->rtag == NORMAL) in_order(root->rchild);
    return ;
}

void clear(Node *root) {
    if (root == NULL) return ;
    if (root->ltag == NORMAL) clear(root->lchild);
    if (root->rtag == NORMAL) clear(root->rchild);
    free(root);
    return ;
}


int main() {
    srand(time(0));
    #define max_op 20
    Node *root = NULL;
    for (int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        root = insert(root, val);
    }
    build_thread(root);
    output(root), printf("\n");
    in_order(root), printf("\n");
    clear(root);
    return 0;
}
~~~



## 广义表和二叉树

### **1.由广义表创建二叉树**

>    借助栈，栈里元素存节点的地址

>   ```c
>   设置一个标记变量 flag，初始为 0；
>   设置一个标记节点 temp,当前层父节current_root(即栈顶元素，每次出栈时赋值给current_root)
>   循环遍历存储广义表的字符串 str：
>   如果 str[i] 是 '('：
>   	(遇到'('此时的p才能当爹，因为'('后面就开始是他的孩子了，这时让他进栈)
>       则设置 flag 为 0；(因为'('后面第一个是他左孩子，要用flag == 0来识别)
>       把 temp 压入栈中。
>       temp = NULL;
>
>   否则如果 str[i] ','：
>       则设置flag为 1; (因为'，'后面一个是他右孩子，要用flag == 1来识别)
>       temp = NULL;
>
>   否则如果 str[i] 是 ')'：
>       则栈顶元素出栈;(当前栈顶元素出栈)
>   	current_root = top(s);
>   	pop(s);
>
>   否则如果 str[i] 是 ' '：break;
>
>   否则如果 str[i] 是一个字母:
>   	用节点 temp 来存储：
>       如果 flag 为 0：
>           将 temp 作为栈顶节点的左孩子；
>       如果 k 为 1：
>           将 temp 作为栈顶节点的右孩子；
>       (另外可以用一个传出参数来记录节点个数)
>         
>   最后要判断栈是否为空，若为空说明没遇到'(',则只有一个根结点，直接把temp赋值给current_root
>   ```

~~~c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct Node{
    char data;
    struct Node *l, *r;
}Node, *pNode;

typedef struct Stack{
    pNode *data;
    int top, size;
} Stack;

void init_stack(Stack *s, int len) {
    s->data = (pNode *)malloc(sizeof(pNode) * len);
    s->size = len;
    s->top = -1;
    return ;
}
int push(Stack *s, pNode p) {
    if(s->top + 1 >= s->size) return 0;
    s->data[++(s->top)] = p;
    return 1;
}
int empty(Stack *s) {
    return s->top == -1;
}
pNode top(Stack *s) {
    if(empty(s)) return NULL;
    return s->data[s->top];
}
int pop(Stack *s) {
    if(empty(s)) return 0;
    s->top -= 1;
    return 1;
}
void clear_stack(Stack *s){
    if(s == NULL) return;
    free(s->data);
    free(s);
    return ;
}


Node* get_node(char c) {
    Node* p = (pNode)malloc(sizeof(Node));
    p->data = c;
    p->l = p->r = NULL;
    return p;
}

void clear_node (Node *node) {
    if(node == NULL) return ;
    if(node->l) clear_node(node->l);
    if(node->r) clear_node(node->r);
    free(node);
    return ;
}

pNode build(char *str, int *tree_node_num) {
    pNode temp = NULL, current_root = NULL;
    Stack *s = (Stack *)malloc(sizeof(Stack));
    init_stack(s, strlen(str));
    int flag = 0;
    while(str[0]) {
        switch (str[0]) {
            case '(' :
                flag = 0;
                push(s, temp);
                temp = NULL;
                break;
            case ',' :
                flag = 1;
                temp = NULL;
                break;
            case ')' :
                current_root = top(s);
                pop(s);
                break;
            case ' ':
                break;
            default :
                temp = get_node(str[0]);
                if(!empty(s) && flag == 0) {
                    s->data[s->top]->l = temp;
                } else if(!empty(s) && flag == 1) {
                    s->data[s->top]->r = temp;
                }
                ++(*tree_node_num);
                break;
        }
        str++;
    }
    if(temp && !current_root) current_root = temp; //一个根结点
    clear_stack(s);
    return current_root;
}

void pre_order(pNode p) {
    if(p == NULL) return ;
    printf("%c ", p->data);
    if(p->l) pre_order(p->l);
    if(p->r) pre_order(p->r);
    return ;
}
void in_order(pNode p) {
    if(p == NULL) return ;
    if(p->l) in_order(p->l);
    printf("%c ", p->data);
    if(p->r) in_order(p->r);
    return ;
}
void post_order(pNode p) {
    if(p->l) post_order(p->l);
    if(p->r) post_order(p->r);
    printf("%c ", p->data);
    return ;
}


int main() {
    char str[35] = {0}, c;
    scanf("%[^\n]s", str);
    int tree_node_num = 0;
    pNode tree = build(str, &(tree_node_num));
    
    
    printf("前序:");
    pre_order(tree);
	printf("\n");
    
    
    printf("中序:");
    in_order(tree);
    printf("\n");


    printf("后序:");
    post_order(tree);
    printf("\n");
    return 0;
}
~~~

### **2.二叉树生成广义表**

>       输出节点存储的值；
>       如果左孩子不为空：
>       	输出 "("；
>       	递归输出左子树；
>       	如果右孩子为空：
>       	输出 ")"。
>       如果右孩子不为空：
>           如果左孩子为空：
>           	输出 "("。
>           输出 “,”；
>           递归输出右子树；
>           输出 ")"。

~~~c
void output(Node *p) {
    if(p == NULL) return ;
    printf("%c", p->data);
    if(p->l == NULL && p->r == NULL) {
        return ;
    }
    printf("(");
    if(p->l) {
        output(p->l);
    }
    if(p->r) {
        printf(",");
        output(p->r);
    }
    printf(")");
 	return ;   
}
~~~

------

# 堆和优先队列

## 概述

![img](https://static.dingtalk.com/media/lALPDgQ9rp3mr13M-c0EVg_1110_249.png?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%22742721380%3A742721380%22%2C%22msgId%22%3A%222356481472671%22%7D&bizType=im&open_id=742721380)

![img](https://static.dingtalk.com/media/lALPDgQ9rp380kHMps0EXg_1118_166.png?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%22742721380%3A742721380%22%2C%22msgId%22%3A%222350400351755%22%7D&bizType=im&open_id=742721380)

## **插入操作：**

1. 把新元素保存在数组的最后。
2. 找到新插入元素的父节点位置。
3. 将新元素与父节点比较大小。
4. 若新插入的元素与其父节点大小不符合堆序性则交换它和父节点的位置，并回到步骤 2；若符合则插入操作完成。

## **删除操作：**

1. 将堆顶元素和最后一个元素交换。
2. 删除堆的最后一个元素。
3. 自顶向下调整元素的位置，使之满足堆序性。

## **堆排序：**(将大根堆有小到大排序为例：)

1. 将变量 i 设为堆末下标。
2. 交换堆顶和第 i 个元素。
3. 自上到下调整堆顶到第 i 个元素之间的堆结构，使之保持堆序性。
4. 将 i 前移一位，重复步骤 2，直至 i 等于 1。

~~~c
//计蒜客写法
#include <stdio.h>
#include <stdlib.h>

typedef struct Heap {
    int *data, size;
} Heap;

void init(Heap *h, int length_input) {
    h->data = (int *)malloc(sizeof(int) * length_input);
    h->size = 0;
}

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void push(Heap *h, int value) {
    h->data[h->size] = value;
    int current = h->size;
    int father = (current - 1) / 2;
    while (h->data[current] > h->data[father]) {
        swap(&h->data[current], &h->data[father]);
        current = father;
        father = (current - 1) / 2;
    }
    h->size++;
}

void output(Heap *h) {
    for (int i = 0; i < h->size; i++) {
        printf("%d ",  h->data[i]);
    }
    printf("\n");
}

int top(Heap *h) {
    return h->data[0];
}

void update(Heap *h, int pos, int n) {
    int lchild = 2 * pos + 1, rchild = 2 * pos + 2;
    int max_value = pos;
    if (lchild < n && h->data[lchild] > h->data[max_value]) {
        max_value = lchild;
    }
    if (rchild < n && h->data[rchild] > h->data[max_value]) {
        max_value = rchild;
    }
    if (max_value != pos) {
        swap(&h->data[pos], &h->data[max_value]);
        update(h, max_value, n);
    }
}

void pop(Heap *h) {
    swap(&h->data[0], &h->data[h->size - 1]);
    h->size--;
    update(h, 0, h->size);
}

// 请在下面实现堆排序函数 heap_sort
void heap_sort(Heap *h) {
    for(int i = h->size - 1; i >= 1; i--) {
        swap(&h->data[i], &h->data[0]);
        update(h, 0, i);
    }
}

void clear(Heap *h) {
    free(h->data);
    free(h);
}

int main() {
    int arr[10] = { 12, 9, 30, 24, 30, 4, 55, 64, 22, 37 };
    Heap *heap = (Heap *)malloc(sizeof(Heap));
    init(heap, 100);
    for (int i = 0; i < 10; i++) {
        push(heap, arr[i]);
    }
    output(heap);
    printf("%d\n", top(heap));
    pop(heap);
    output(heap);
    heap_sort(heap);
    output(heap);
    clear(heap);
    return 0;
}
~~~

## 线性建堆-堆排序

>   上面入堆操作是**从下向上**，每次进来一个放堆尾，再去维护，维护时反复跟父节点比较，Olog(n)

>   初始化建堆：
>
>   其实可以直接把所有元素先放数组里再一起去建堆，这时采用上面删除元素时**自上而下**的操作，从第n/2个元素到第一个元素每个元素(即非叶子节点)进行**自上而下**操作(下虑)，即反复让其与两个子节点比较直到不满足条件，所有点操作完就建好了一个堆O(n)

>   维护堆(重建堆)：
>
>   堆排序和建堆相同的操作，只不过这次是去维护堆，每次将堆顶元素(最值元素)跟倒数第i位交换堆就破环了再去将堆顶元素自上而下下虑维护堆，依次将所有堆顶元素放到后面就完成了排序nlog(n)

~~~c
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

void updata(int *arr, int ind, int n) {
    //int temp = ind;      //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx写循环内
    while((ind << 1) <= n) { //xxxxxxxxxxxxxxxxxxxxxx
        int temp = ind, l = ind * 2, r = ind * 2 + 1;
        if(arr[l] > arr[temp]) {
            temp = l;
        }
        if(r <= n && arr[r] > arr[temp]) { //xxxxxxxx
            temp = r;
        }
  
        if(temp == ind) break;   //xxxxxxxxxxxxxxxxxxxxxxx漏写

        swap(arr[ind], arr[temp]);
        ind = temp;
    }
}

void heap_sort(int *arr, int n) {
    arr -= 1;
    //初建堆
    for(int i = n >> 1; i >= 1; i--) {
        updata(arr, i, n);
    }
    //排序重建堆
    for(int i = n; i > 1; i--) {
        swap(arr[i], arr[1]);
        updata(arr, 1, i - 1);
    }
    return ;
}

void output(int *arr, int n) {
    for(int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return ;
}

int main() {
    srand(time(0));
    int n, val;
    scanf("%d", &n);
    int *arr = (int *)malloc(sizeof(int) * n);
    for(int i = 0; i < n; i++) {
        val = rand() % 100;
        arr[i] = val;
    }
    output(arr, n);
    heap_sort(arr, n);
    output(arr, n);
    free(arr);
    return 0;
}
~~~



## 优先队列

其实就是堆

| 普通队列 |     (最大/最小)堆     |
| :--: | :--------------: |
| 尾部入队 |      尾部可以插入      |
| 头部入队 |      头部可以弹出      |
| 先进先出 | 每次出对权值(最大/最小的元素) |
| 数组实现 |   数组实现，逻辑上看成堆    |



---

# 哈希表



## 哈希函数

>   1.**直接寻址法**。取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）
>
>   2.**数字分析法**。分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。
>
>   3.**平方取中法。**取关键字平方后的中间几位作为散列地址。
>
>   4.**折叠法。**将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。
>
>   5.**随机数法**。选择一随机函数，取关键字作为随机函数的种子生成随机值作为散列地址，通常用于关键字长度不同的场合。
>
>   6.**除留余数法**。取关键字被某个不大于表长m的数p除后所得的余数为散列地址。即 $H(key) = key \% p,p<=m$.不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生碰撞。



## 解决冲突的办法

>   **1. 开放定址法**(常用)
>
>   如果发⽣冲突，那么就使⽤某种策略寻找下⼀存储地址，直到找到⼀个不冲突的地址或者找到关键字，否则⼀直按这种策略继续寻找。如果冲突次数达到了上限则终⽌程序，表⽰关键字不存在哈希表⾥。常⻅的策略有这⼏种：
>
>   >   1.  线性探测法，如果当前的冲突位置为 d，那么接下来⼏个探测地址为d + 1，d + 2,  等，也就是从冲突地址往后⾯⼀个⼀个探测
>   >   2.  线性补偿探测法，它形成的探测地址为 d + m，d + 2 * m ，d + 3 * m等，与线性探测法不同，这⾥的查找单位不是 1，而是 m，为了能遍历到哈希表⾥所有位置，我们设置m 和表⻓szie互质；
>   >   3.  随机探测法，这种⽅法和前两种⽅法类似，这⾥的查找单位不是⼀个固定值，而是⼀个随机序列。
>   >   4.  ⼆次探测法，它形成的探测地址为 d + 1^2，d - 1^2 ，d + 2^2，d - 2^2 等，这种⽅法在冲突位置左右跳跃着寻找探测地址。
>
>   **2. 拉链法**(常用)
>
>   该⽅法将所有哈希地址相同的结点构成⼀个单链表，单链表的头结点存在哈希数组⾥。链地址法常出现在经常插⼊和删除的情况下。优点：不会出现“堆聚”现象，哈希地址不同的关键字不会发⽣冲突；不需要重建哈希表，在开放地址法中，如果哈希表⾥存满关键字了就需要扩充哈希表然后重建哈希表
>
>   **3. 再哈希法**
>
>   Hi=RHi(key),i=1,2,…，k RHi均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。
>
>   **4. 建立公共溢出区**
>
>   冲突次数大于表长的一般时认为堆聚，需要重建
>
>   >   1.开辟一段和当前哈希表等大的临时存储空间。
>   >
>   >   ​	2.将原哈希表里的关键字一一复制到临时数组里。
>   >
>   >   ​	3.申请一个大小是现在两倍的新的存储空间，释放原空间。
>   >
>   >   ​	4.将新空间里的存储地址初始化。
>   >
>   >   ​	5.将关键字从临时数组复制到新的空间，释放临时空间。



## 字符串哈希函数

>    常见字符串哈希函数：**BKDRHash ， APHash ， DJBHash ， JSHash ， RSHash**

```c
//BKDRHash 法
int BKDRHash(char *str) {
    int seed = 31, hash = 0;
    for(int i = 0; str[i]; i++) hash = hash * seed + str[i];
    return hash & 0x7fffffff;
}
```

拉链法写

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
typedef struct Node {
    char *str;
    struct Node *next;
} Node;

typedef struct HashTable {
    Node **data;
    int size;
} HashTable;

Node *init_node(char *str, Node *head) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->str = strdup(str);
    p->next = head;
    return p;
}

HashTable *init_hashtable(int n) {
    HashTable *h = (HashTable *)malloc(sizeof(HashTable));
    h->size = n << 1;
    h->data = (Node **)calloc(h->size, sizeof(Node *));
    return h;
}

int BKDRHash(char *str) {
    int seed = 31, hash = 0;
    for(int i = 0; str[i]; i++) hash = hash * seed + str[i];
    return hash & 0x7fffffff;
}

int insert(HashTable *h, char *str) {
    int hash = BKDRHash(str);
    int ind = hash % h->size;
    h->data[ind] = init_node(str, h->data[ind]);
    return 1;
}

int search(HashTable *h, char *str) {
    int hash = BKDRHash(str);
    int ind = hash % h->size;
    Node *p = h->data[ind];
    while(p && strcmp(p->str, str)) p = p->next; //条件不能出错xxxxxxxxxxx
    return p != NULL;
} 

void clear_node(Node *node) {
    if(node == NULL) return ;
    Node *p = node, *q;
    while(p) {
        q = p->next;
        free(p->str);
        free(p);
        p = q;
    }
    free(q);
    return ;
}

void clear_hashtable(HashTable *h) {
    if(h == NULL) return ;
    for(int i = 0; i < h->size; i++) clear_node(h->data[i]);
    free(h->data);
    free(h);
    return ;
}

int main() {
    int op;
    #define max_n 100
    char str[max_n + 5];
    HashTable *h = init_hashtable(max_n + 5);
    while(~scanf("%d%s", &op, str)) {
        switch(op) {
            case 0:
               printf("insert %s to hash to table\n", str);
               insert(h, str);
               break;
            case 1:
               printf("search %s from has table result = %d\n", str, search(h, str));
               break;
        }
    }
    clear_hashtable(h);
    return 0;
}
```





---

# 排序

## 稳定排序：

>   常见稳定排序:**插入排序，冒泡排序，归并排序**

### 插入排序

>   **基本思想：**是将线性表分为已排序的前半部分和待排序的后半部分，从待排序部分选出第⼀个元素，插⼊到已排序部分的对应位置中，直到全部记录都插⼊到已排序部分中。总体时间复杂度O(n^2);

![](https://res.jisuanke.com/img/upload/20160304/3eca19c223fd1d9bffaff6a240fbbac00c400b84.gif)

### 冒泡排序

>   **基本思想：**将n个元素比较$n - 1$趟，每一趟比较$n - i$次(即待排元素个数减一)，每一趟都将待排中最大的排到了最后面。时间复杂度O(n^2)

![](https://res.jisuanke.com/img/upload/20160304/044b7de55573d738ad71c7820f628a76df26d6c9.gif)

### 归并排序

>   **基本思想：**将两个有序表合成一个有序表，两个有序表如何得到？将原表从中间分成两半，递归的求两边，最后进行一下合并。归并一共进行$O(logn)$层归并，每层时间复杂度$O(n)$,总体时间复杂度$O(nlogn)$,每次合并时要开辟临时空间存储，然后再复制过去，空间复杂度$O(n)$

![](https://res.jisuanke.com/img/upload/20160303/012e9ba7cd5dcbc4f0ccb7caa185e4f9769d29ed.gif)

**代码：**

~~~c
#define swap(a, b) {\
    a ^= b; b ^= a; a ^= b;\
}
//插入排序
void insert_sort(int *num, int n) {
    for(int i = 1; i < n; i++) {
        for(int j = i; j > 0 && num[j] < num[j-1]; j--) {
            swap(num[j], num[j - 1]);
        }
    }
    return ;
}
//冒泡排序
void bubble_sort(int *num, int n) {
    int times = 1;
    for(int i = 1; i < n && times; i++) {
        times = 0;
        for(int j = 0; j < n - i; j++) {
            if(num[j] > num[j + 1]) {
                swap(num[j], num[j + 1]);
                times++;
            }
        }
    }
    return ;
}
//归并排序
void merge_sort(int *num, int l, int r) {
  	//if(l == r) return ;
    if(r - l <= 1) {
        if(r - l == 1 && num[l] > num[r]) {
            swap(num[l], num[r]);
        }
        return ;
    }
    int mid = (l + r) >> 1;
    merge_sort(num, l, mid);
    merge_sort(num, mid + 1, r);
    int *temp = (int *)malloc(sizeof(int) * (r - l + 1));
    int p1 = l, p2 = mid + 1, k = 0;
    while(p1 <= mid || p2 <= r) {
        if(p2 > r || (p1 <= mid && num[p1] <= num[p2])) {
            temp[k++] = num[p1++];
        } else {
            temp[k++] = num[p2++];
        }
    }
    memcpy(num + l, temp, sizeof(int) * (r - l + 1));
    free(temp);
    return ;

}
~~~



## 非稳定排序：

>   常见的不稳定排序算法有**选择排序(selection sort)、快速排序(quick sort)、堆排序(heap sort)、希尔排序(shell sort)**

### 选择排序

>   **基本思想：**分成已排序区(在前)和待排序区,每次从待排序区中找出最小的放已排序的最后面即放在待排序的第一位。或这样理解，一趟都将待排序区的最小值放最前面(跟待排序第一个数交换)，待排序区的元素每趟都会少一个。因为在找待排序区中最小元素时都是将后面的元素跟第一个比较，找到后跟第一个数交换位置，因此可知会打乱后面与第一个数相等的数他俩的相对位置，所以选择排序是**不稳定**的。也有可能第一个数就是待排区中的最小的数，这时候在写swap函数时就不能用异或运算来写，同一个地址的元素异或交换就变成0了。时间复杂度O(n^2)

![img](https://res.jisuanke.com/img/upload/20160304/9c965158bc6178ef603ade226071fabb9a624a67.gif)

### 快速排序

>   **基本思想：**选一个基准值,利用双指针将所有小于基准值的元素放到左边，所有大于基准值的元素放到右边，再递归的将左右两边元素分别排序。平均时间复杂度O(log(n)),最坏O(n^2)

![img](https://res.jisuanke.com/img/upload/20160304/7a3c9a32f9e675cab345ef47dcd9c0db087105f8.gif)

**代码**：

~~~c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}
//函数测试框架，稳定排序一样用法
#define TEST(arr, n, func, args...) {\
    int *num = (int *)malloc(sizeof(int) * n);\
    memcpy(num, arr, sizeof(int) * n);\
    output(num, n);\
    printf("%s = ", #func);\
    func(args);\
    output(num, n);\ 
    free(num);\
}
//选择排序
void select_sort(int *num, int n) {
    for(int i = 0; i < n - 1; i++) {
        int ind = i;
        for(int j = i + 1; j < n; j++) {
            if(num[j] < num[ind]) ind = j;
        }
        swap(num[i], num[ind]);
    }
    return ;
}
//快速排序
void quick_sort(int *num, int l, int r) {
    if(r < l) return ;
    int x = l, y = r, pivot = num[l];
    while(x < y) {
        //先从右边开始找第一个小于Pivot的值
        while(x < y && num[y] >= pivot) y--;
        if(x < y) num[x++] = num[y];
        while(x < y && num[x] <= pivot) x++;
        if(x < y) num[y--] = num[x];
    }
    num[x] = pivot;
    quick_sort(num, l, x - 1);
    quick_sort(num, x + 1, r);
    return ;
}


void randint(int *arr, int n) {
    while(n--) arr[n] = rand() % 100;
    return ;
}


void output(int *num, int n) {
    printf("[ ");
    for(int i = 0; i < n; i++) {
        printf("%d ", num[i]);
    }
    printf("]\n");
    return ;
}

int  main() {
    srand(time(0));
    #define max_op 15
    int arr[max_op];
    randint(arr, max_op);
    TEST(arr, max_op, select_sort, num, max_op);
    TEST(arr, max_op, quick_sort, num, 0, max_op - 1);
    return 0;
}
~~~



# 查找

## 二分查找：

解决的是将问题规模减小

1.  **普通情况：**

    在有序序列找一个数

    ~~~c
    //1 3 5 7 9 10 ......
    int binary_search1(int *num, int n, int x) {
        int head = 0, tail = n - 1, mid;
        while(head <= tail) {
            mid = (head + tail) >> 1;
            if(num[mid] == x) return mid;
            if(num[mid] < x) head = mid + 1;
            else tail = mid - 1;
        }
        return -1;
    }  
    ~~~

2.  **`000000011111`情况:**

    找第一个1的位置

    ~~~c
    int binary_search2(int *num, int n) {
        int head = 0, tail = n, mid; // 一定存在答案的话，应该可以tail = n - 1开始。。
        while(head < tail) {
            mid = (head + tail) >> 1; //重点注意
            if(num[mid] == 1) tail = mid;
            else head = mid + 1;
        }
        return head == n ? -1 : head;
    }
    ~~~

    ① $mid = (head + tail) / 2$

        如果此时
        0 0 0 0 0 0 1 1 1 1 
        		↑ ↑
          		l r
        下一次 mid = (l + r) / 2 == l
        更新 r = mid = l;
        正好得到答案不会死循环，所以求 mid 时 l + r 不用再加1
        11111110000的情况则不同(下面分析)
    ② $head = mid + 1$

    ~~~
    000000011111
         ↑
    head = mid + 1;

    如果此时 mid 指向的是0那么他一定不是答案，所以舍去 mid 及前面的
    ~~~

    ③ $tail = mid$

    ~~~
    000000011111
             ↑
    tail = mid;

    如果此时 mid 指向的是1那么他 有可能 是答案，所以留下 mid， 舍弃mid后面的
    ~~~

3.  **`111111111100000`情况**

    求最后一个1的位置

    ```c
    int binary_search3(int *num, int n) {
        int head = -1, tail = n - 1, mid; //一定存在答案的话，应该可以head = 0开始。。
        while(head < tail) {
            mid = (head + tail + 1) >> 1; //重点关注
            if(num[mid] == 1) {
                head = mid;
            } else tail = mid - 1;
        }
        return head;
    }
    ```

    ① $mid = (head + tail + 1) / 2$

    ```
    如果此时
    1 1 1 1 1 1 1 1 0 0 0 0
          		↑ ↑
          		l r

    如果 mid = (l + r) / 2;
    那么下一次 mid = (l + r) / 2 == l;
    	  更新 l = mid = l; l 还是 l这时就会死循环
    	  
    所以应该 mid = (head + tail + 1) / 2；
    ```

    ② $head = mid$

    ```
    11111110000000000000
         ↑
    head = mid;

    如果此时 mid 指向的 1 ,那么他有可能是答案，所以舍去 mid 前面的，留下 mid
    ```

    ③ $tail = mid$

    ```
    1111110000000
             ↑
    tail = mid - 1;

    如果此时 mid 指向的是 0 那么他一定不是答案，所以舍弃 mid 及后面的
    ```

## 三分查找：

>   在一个单调函数中，用二分查找精确求解中某一点的值。如果函数是一个 凸性函数（在某一点左侧，函数递增，在该点右侧，函数递减，该点称为极大值点）或者 凹性函数（在某一点左侧，函数递减，在该点右侧，函数递增，该点称为极小值点）求最值就要用到三分查找

![img](https://static.dingtalk.com/media/lALPDgQ9ruuRqcnNAV3NASo_298_349.png?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222421617606380%22%7D&bizType=im&open_id=742721380)



 	三分查找每次比较后，都会将区间长度缩小到原来的$2/3$  。时间复杂度Olog(n);

```c
//凸函数代码
//凹函数只需要把10，16行大于改成小于即可
#include <stdio.h>

int find_max(int *data, int length) {
    int left = 0, right =length - 1;
    while(right - left >= 2) {
        int m1 = left + (right - left) / 3;
        int m2 = right - (right - left + 2) / 3; //尽量让m2靠近极值点
        if(data[m1] >= data[m2]) {
            right = m2;
        } else {
            left = m1 + 1;//尽量让m1靠近极值点
        }
    }
    if(data[left] >= data[right]) {
        return left;
    } else {
        return right;
    }
}

int main() {
    int a[5] = {1, 2, 7, 5, 4};
    printf("%d\n", find_max(a, 5));
    return 0;
}
```

----

# 平衡二叉查找树

## 二叉排序树

又称二叉搜索树

>   **左子树 < 根结点 **  
>
>   **右子树 > 根结点**
>
>   用途: **解决排名相关的检索需求**
>
>   ⼆叉查找树插⼊查找的效率都是 O(log n)，最坏情况下是 O(n)

### 二叉查找树插入

>    小于根结点插左子树，大于根结点插右子树

### 二叉查找树删除

>   1.  **删除叶子节点**
>
>   2.  **删除出度为1的节点**
>
>       如图删除3
>
>       ![图片](https://static.dingtalk.com/media/lALPDgQ9rw5rAP50dA_116_116.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222456832909739%22%7D&bizType=im&open_id=742721380) 		➡ 		![图片](https://static.dingtalk.com/media/lALPDgQ9rw6Kb8Btdg_118_109.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222460273104549%22%7D&bizType=im&open_id=742721380)
>
>   3.  **删除出度为2的节点**
>
>       先找到前驱或后继，然后替换后转换为出度为1的节点问题
>
>       如图删除20
>
>       ###### ![img](https://static.dingtalk.com/media/lALPDgQ9rw8TRfV0zI0_141_116.png?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222450865983941%22%7D&bizType=im&open_id=742721380)➡![img](https://static.dingtalk.com/media/lALPDgQ9rw8TRxBvzIc_135_111.png?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222457232501317%22%7D&bizType=im&open_id=742721380)➡ ![图片](https://static.dingtalk.com/media/lALPDgQ9rw8ZDHJ0zI4_142_116.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222450929783642%22%7D&bizType=im&open_id=742721380)➡ ![img](https://static.dingtalk.com/media/lALPDgQ9rw8ZDUtyzIY_134_114.png?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222450929862141%22%7D&bizType=im&open_id=742721380)

```c
#include <stdlib.h>
#include <stdio.h>

typedef struct Node {
    int key;
    struct Node *lchild, *rchild;
} Node;

Node *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->lchild = p->rchild = NULL;
    return p;
}

Node *insert(Node *root, int key) {
    if(root == NULL) return getNewNode(key);
    if(root->key == key) return root;
    if(key < root->key) root->lchild = insert(root->lchild, key);
    else root->rchild = insert(root->rchild, key);
    return root;
}

Node *predecessor(Node *root) {
    Node *temp = root->lchild;
    while(temp->rchild) temp = temp->rchild;
    return temp;
}
//删除节点重要！
Node *erase(Node *root, int key) {
    if(root == NULL) return root;
    if(key < root->key) root->lchild = erase(root->lchild, key);
    else if(key > root->key) root->rchild = erase(root->rchild, key);
    else {
        //度为一或0
        if(root->lchild == NULL || root->rchild == NULL) {
            Node *temp = root->lchild ? root->lchild : root->rchild;
            free(root);
            return temp;
        } else {
            //度为2的节点
            Node *temp = predecessor(root);
            root->key = temp->key;
            root->lchild = erase(root->lchild, temp->key);
        }
    }
    return root;
}

void __in_order(Node *root) {
    if(root == NULL) return ;
    __in_order(root->lchild);
    printf("%d ", root->key);
    __in_order(root->rchild);
    return ;
}

void in_order(Node *root) {
    printf("in order output: ");
    __in_order(root);
    printf("\n");
}

void clear(Node *root) {
    if(root == NULL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

int main() {
    int op, val;
    Node *root = NULL;
    while(~scanf("%d%d", &op, &val)) {
        switch(op) {
            case 1:
                root = insert(root, val);
                break;
            case 2:
                root = erase(root, val);
                break;
        }
        in_order(root);
    }
    clear(root);
    return 0;
}
```

----

## 平衡二叉查找树



### AVL树

1.  **平衡条件**：每个节点左右子树最大高度差不超过1
2.  **四种旋转操作：**
    1.  LL型
    2.  LR型：首先是左子树比右子树高度差为2了，又左子树的右子树比左子树的左子树高，此时需要先站在左孩子处进行小左旋，再站在当前节点进行大右旋
    3.  RL型
    4.  RR型

 ![img](https://static.dingtalk.com/media/lALPDhJzsOG6K6PNB4_NApY_662_1935.png?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%22742721380%3A742721380%22%2C%22msgId%22%3A%223631777592062%22%7D&bizType=im&open_id=742721380)



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define H(root) (root)->h
#define L(root) (root)->l
#define R(root) (root)->r
#define K(root) (root)->key

typedef struct Node {
    int key, h;
    struct Node *l, *r;
} Node;

Node __NIL;
#define NIL (&__NIL)
__attribute__((constructor))
void init_NIL() {
    NIL->key = NIL->h = 0;
    NIL->l = NIL->r = NIL;
    return ;
}

Node *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->h = 1;
    p->l = p->r = NIL;
    return p;
}
void update_height(Node *root) {
    root->h = H(L(root))> H(R(root)) ? H(L(root)) : H(R(root)) + 1;
}

Node *left_rotate(Node *root) {
    Node *temp = root->r;
    root->r = temp->l;
    temp->l = root;
    update_height(root);
    update_height(temp);
    return temp;
}

Node *right_rotate(Node *root) {
    Node *temp = root->l;
    root->l = temp->r;
    temp->r = root;
    update_height(root);
    update_height(temp);
    return temp;
}


Node *maintain(Node *root) {
    if (abs(H(L(root)) - H(R(root))) <= 1) return root;
    if (H(L(root)) > H(R(root))) {
        if(H(R(L(root))) > H(L(L(root)))) {
            root->l = left_rotate(root->l);
        }
        root = right_rotate(root);
    } else {
        if(H(L(R(root))) > H(R(R(root)))) {
            root->l = right_rotate(root->l);
        }
        root = left_rotate(root);
    }
    return root;
}

Node *insert(Node *root, int key) {
    if (root == NIL) return getNewNode(key);
    if (root->key == key) return root;
    if (root->key > key) {
        root->l = insert(root->l, key);
    } else root->r = insert(root->r, key);
    update_height(root);  //插入一节点就要更新树高
    return maintain(root);
}

void clear(Node *root) {
    if (root == NIL) return ;
    clear(root->l);
    clear(root->r);
    free(root);
} 
Node *predeccessor(Node *root) {
    Node *temp = root->l;
    while (temp->r != NIL) temp = temp->r;
    return temp;
}
Node *erase(Node *root, int key) {
    if (root == NIL) return root;
    if (root->key > key) root->l = erase(root->l, key);
    else if (root->key < key) {
        root->r = erase(root->r, key);
    } else {
        if (root->l == NIL || root->r == NIL) {
            Node *temp = root->l == NIL ? root->r : root->l;
            free(root);
            return temp;
        } else {
            Node *temp = predeccessor(root);
            root->key = temp->key;
            root->l = erase(root->l, temp->key);
        }
    }
  	update_height(root);
    return maintain(root);
}

void output(Node *root) {
    if (root == NIL) return ;
    printf("(%d %d %d)\n", K(root), K(L(root)), K(R(root)));
    output(root->l);
    output(root->r);
    return ;
}


int main() {
    #define MAX_OP 20
    Node *root = NIL;
    for(int i = 0; i < MAX_OP; i++) {
        int val = rand() % 100;
        root = insert(root, val);
    }
    output(root);
    int val;
    while(~scanf("%d", &val)) {
        root = erase(root, val);
        printf("erase %d from tree", val);
        output(root);
    }
    return 0;
}

```



### 红黑树

#### 五个平衡条件

-   每个结点要么是红色，要么是黑色；
-   根结点是黑色；
-   叶结点（NIL）是黑色；
-   如果一个结点是红色，则它的两个子节点都是黑色的；
-   从根结点出发到所有叶结点的路径上，均包含相同数目的黑色结点。



**提示：调整时要明确哪些点的颜色是确定的哪些是不确定的，调整前后要保证这个子树上面的黑色数量没有改变**

#### 插入调整(两种情况)

==站在祖父节点往下看是否有颜色冲突(看儿子和孙子是不是同时为红色)==



##### 叔叔红

>    ![图片](https://static.dingtalk.com/media/lALPDiQ3LK3lWhnM2M0BzQ_461_216.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%22742721380%3A742721380%22%2C%22msgId%22%3A%224064208514998%22%7D&bizType=im&open_id=742721380)
>
>   方案：直接红上顶
>
>    ![img](https://res.jisuanke.com/img/upload/20170111/ad621d7d3ab7553d8aaa5a1cfae8ac332ad5c3ca.png)



##### 叔叔黑(我位置有4种情况)

>    **LR型**：先小左旋(注意观察小左旋并不影响路径上黑色节点数量)，转化为LL型
>
>    ![img](https://res.jisuanke.com/img/upload/20170111/63cf075299c91a45765a79983048af2940d97e95.png)
>
>    ![img](https://res.jisuanke.com/img/upload/20170111/0642f1714a1f030013d31901f0ced2647cd152d4.png)
>
>   **LL型**：直接大右旋，再调帽子为红黑黑或黑红红
>
>    ![img](https://res.jisuanke.com/img/upload/20170111/cdf89cf1677f650776bf0d4440e5ef42ad6438fc.png)
>
>   **RR、RL和上面一样**



#### 删除调整(三种情况)

**删除操作站在父节点往下看**

分析删除只有一个孩子的结点的情况：如果要删除的结点 x 为红色，那么这个结点的父结点和子结点都一定是黑色，因此，只需要把子结点直接连向父结点就可以了，不会破坏红黑树的五条规则。如果删除的黑色节点，就需要把该结点下的子树的根结点变为双重黑

调整操作就是为了干掉双重黑



其中分兄弟黑和兄弟红，兄弟红可以转为兄弟黑情况，这里主要分兄弟黑的三种情况

##### 黑兄弟的儿子全黑

>   x为双重黑
>
>    ![img](https://res.jisuanke.com/img/upload/20170117/ed15c408bc20011e52a9dfc148f1aa0507127d35.png)
>
>   方案：黑上浮（当根结点为双重黑时，直接减一就行）
>
>    ![img](https://res.jisuanke.com/img/upload/20170117/78dd99072d4b8138ba1c8dfd51295c30ca541b9c.png)

##### RR或LL型

LL黑兄弟是左孩子，黑兄弟的左孩子是只要是红色(不关心另一个孩子颜色)

RR黑兄弟是右孩子，黑兄弟的右孩子是只要是红色(不关心另一个孩子颜色)

>   站在38大左旋，
>
>    ![img](https://res.jisuanke.com/img/upload/20170117/bcce6388a541eebf4632afdf6ba9bf23c9f0ffd3.png)
>
>   **调色：51调成38的颜色，38和72调成黑色**
>
>    ![img](https://res.jisuanke.com/img/upload/20170117/ce7683bbed82a149e4bdeecf32296905daa05634.png)



##### RL或LR型

>    ![img](https://res.jisuanke.com/img/upload/20170117/62b1e7e6946d2b4f0eb6de8b7e7652a0242e5635.png)
>
>   **先小右旋，交换51调黑72调红，变成了RR型**
>
>    ![img](https://res.jisuanke.com/img/upload/20170117/bcce6388a541eebf4632afdf6ba9bf23c9f0ffd3.png)



#### 代码

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define RED 0
#define BLACK 1
#define DBLACK 2

typedef struct Node {
    int key;
    int color; // 0 red, 1 black, 2 double black
    struct Node *lchild, *rchild;
} Node;

Node __NIL;
#define NIL (&__NIL)

__attribute__((constructor))
void init_NIL() {
    NIL->key = 0;
    NIL->lchild = NIL->rchild = NIL;
    NIL->color = BLACK;
    return ;
}

Node *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->lchild = p->rchild = NIL;
    p->color = RED;
    return p;
}

bool has_red_child(Node *root) {
    return root->lchild->color == 0 || root->rchild->color == 0;
}

Node *left_rotate(Node *root) {
    Node *temp = root->rchild;
    root->rchild = temp->lchild;
    temp->lchild = root;
    return temp;
}

Node *right_rotate(Node *root) {
    Node *temp = root->lchild;
    root->lchild = temp->rchild;
    temp->rchild = root;
    return temp;
}

Node *insert_maintain(Node *root) {
    if (!has_red_child(root)) return root;
    if (root->lchild->color == RED && root->rchild->color == RED) {
        root->color = RED;
        root->lchild->color = root->rchild->color = BLACK;
        return root;
    }
    if (root->lchild->color == RED) {
        if (!has_red_child(root->lchild)) return root;
        if (root->lchild->rchild->color == RED) {
            root->lchild = left_rotate(root->lchild);
        }
        root = right_rotate(root);
    } else {
        if (!has_red_child(root->rchild)) return root;
        if (root->rchild->lchild->color == RED) {
            root->rchild = right_rotate(root->rchild);
        }
        root = left_rotate(root);
    }
    root->color = RED;
    root->lchild->color = root->rchild->color = BLACK;
    return root;
}

Node *predeccessor(Node *root) {
    Node *temp = root->lchild;
    while (temp->rchild != NIL) temp = temp->rchild;
    return temp;
}

Node *erase_maintain(Node *root) {
    if (root->lchild->color != DBLACK &&
        root->rchild->color != DBLACK) return root;
    if (has_red_child(root)) {
        root->color = RED;
        if (root->lchild->color == RED) {
            root = right_rotate(root);
            root->rchild = erase_maintain(root->rchild);
        } else {
            root = left_rotate(root);
            root->lchild = erase_maintain(root->lchild);
        }
        root->color = BLACK;
        return root;
    }
    if ((root->lchild->color == DBLACK && !has_red_child(root->rchild)) ||
        (root->rchild->color == DBLACK && !has_red_child(root->lchild))) {
        root->color += 1;
        root->lchild->color -= 1;
        root->rchild->color -= 1;
        return root;
    }
    if (root->rchild->color == BLACK) {
        if (root->rchild->rchild->color != RED) {
            root->rchild->color = RED;
            root->rchild = right_rotate(root->rchild);
            root->rchild->color = BLACK;
        }
        root->rchild->color = root->color;
        root->color = BLACK;
        root->lchild->color -= 1;
        root = left_rotate(root);
        root->rchild->color = BLACK;
    } else {
        if (root->lchild->lchild->color != RED) {
            root->lchild->color = RED;
            root->lchild = left_rotate(root->lchild);
            root->lchild->color = BLACK;
        }
        root->lchild->color = root->color;
        root->color = BLACK;
        root->rchild->color -= 1;
        root = right_rotate(root);
        root->lchild->color = BLACK;
    }
    return root;
}

Node *__erase(Node *root, int key) {
    if (root == NIL) return root;
    if (root->key > key) {
        root->lchild = __erase(root->lchild, key);
    } else if (root->key < key) {
        root->rchild = __erase(root->rchild, key);
    } else {
        if (root->lchild == NIL || root->rchild == NIL) {
            Node *temp = root->lchild == NIL ? root->rchild : root->lchild;
            temp->color += root->color;
            free(root);
            return temp;
        } else {
            Node *temp = predeccessor(root);
            root->key = temp->key;
            root->lchild = __erase(root->lchild, temp->key);
        }
    }
    return erase_maintain(root);
}

Node *erase(Node *root, int key) {
    root = __erase(root, key);
    root->color = BLACK;
    return root;
}

Node *__insert(Node *root, int key) {
    if (root == NIL) return getNewNode(key);
    if (root->key == key) return root;
    if (root->key > key) {
        root->lchild = __insert(root->lchild, key);
    } else {
        root->rchild = __insert(root->rchild, key);
    }
    return insert_maintain(root);
}

Node *insert(Node *root, int key) {
    root = __insert(root, key);
    root->color = BLACK;
    return root;
}

void clear(Node *root) {
    if (root == NIL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

void output(Node *root) {
    if (root == NIL) return ;
    printf("(%d | %d, %d, %d)\n",
        root->color,
        root->key,
        root->lchild->key,
        root->rchild->key
    );
    output(root->lchild);
    output(root->rchild);
    return ;
}

int main() {
    int op, val;
    Node *root = NIL;
    while (~scanf("%d%d", &op, &val)) {
        switch (op) {
            case 0: root = insert(root, val); break;
            case 1: root = erase(root, val); break;
        }
        output(root);
    }
    return 0;
}

```









---



# 并查集

>   解决连通性问题
>
>   ###### ![图片](https://static.dingtalk.com/media/lALPDgQ9rxNxnerNAVDM1A_212_336.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222453825710638%22%7D&bizType=im&open_id=742721380)![图片](https://static.dingtalk.com/media/lALPDgQ9rxOBt7zNAVfNATE_305_343.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222453825748618%22%7D&bizType=im&open_id=742721380)

>   **MAKE—SET(x)：初始化操作：建立一个只包含x的元素，每个元素开始都是指向自己**
>
>   **FIND—SET(x) 查询操作：找到x所在的集合**
>
>   **UNION(x, y) 合并操作：将两棵树合并**
>
>   ###### **![img](https://static.dingtalk.com/media/lALPDgQ9rxHQ3_jMx80Bzg_462_199.png?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222460224223659%22%7D&bizType=im&open_id=742721380)**

>   **不加优化的并查集，最坏情况森林会退化成链表，查询时间复杂度为O(N)**



### Quick-Find

>   将所有连通的即属于同一集合的元素都染成代表元素的颜色，在树中就是都指向最终根结点，路径压缩就是这样子

~~~c
typedef struct UnionSet {
    int *color;
    int n;
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet));
    u->color = (int *)malloc(sizeof(int) * (n + 1));
    u->n = n;
    for(int i = 1; i <= n; i++) {
        u->color[i] = i;
    }
    return u;
}

//查找
int find(UnionSet *u, int x) {
    return u->color[x];
}
//合并
int merge(UnionSet *u, int a, int b) {
    if(find(u, a) == find(u, b)) return 0;
    int color_a = u->color[a];
    for(int i = 1; i <= u->n; i++) {
        if(u->color[i] - color_a) continue;
        u->color[i] = u->color[b];
    }
    return 1;
}
~~~



### Quick-Union

>   >   **解释：[x, y], 将x所在集合连通到y所在集合, x所在集合的代表为X，y所在集合的代表为Y，a[X] = Y**
>
>   例：用Quick-Union算法求的下面十个点最终数组结果
>
>   ###### ![图片](https://static.dingtalk.com/media/lALPDgQ9rxLBpdLMk80DYw_867_147.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222460064600293%22%7D&bizType=im&open_id=742721380)
>
>   ###### ![图片](https://static.dingtalk.com/media/lALPDgQ9rxLUTUpszQFs_364_108.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222460784414992%22%7D&bizType=im&open_id=742721380)画成树：![图片](https://static.dingtalk.com/media/lALPDgQ9rxLUTznMlX0_125_149.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222460880076369%22%7D&bizType=im&open_id=742721380)
>
>   >   缺点：这样规定x做孩子连在y下面,极端情况下会退化成链表，优化看Weighted Quick-Union

~~~c
typedef struct UnionSet {
    int *father;
    int n;
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet));
    u->father = (int *)malloc(sizeof(int) * (n + 1));
    u->n = n;
    for(int i = 1; i <= n; i++) {
        u->father[i] = i;
    }
    return u;
}

//查找
int find(UnionSet *u, int x) {
    if(u->father[x] == x) return x;
    return find(u, u->father[x]);
}

//合并
int merge(UnionSet *u, int a, int b) {
    int fa = find(u, a), fb = find(u, b);
    if(fa == fb) return 0;
    u->father[fa] = fb;
    return 1;
}
~~~



### Weighted Quick-Union

>   >   这就是：**按秩合并**
>   >
>   >   解释：[x, y], 将x所在集合和y所在集合合并, 秩小的做孩子，秩大的做父亲
>
>   秩是按照**节点数量**比较还是**树的高度**比较呢？ ➟    **节点数量**
>
>   通俗理解：像下面这种情况，就应该将树二接到树一下面，这样查询效率更高
>
>   ![图片](https://static.dingtalk.com/media/lALPDgQ9rxMx5GddzO4_238_93.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222463521382001%22%7D&bizType=im&open_id=742721380)![img](https://static.dingtalk.com/media/lALPDgQ9rxMx5CdNzPM_243_77.png?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222463537261583%22%7D&bizType=im&open_id=742721380)
>
>   公式推倒：$l_i$ 表示第$i$个点查询的次数，所有点查询总次数除以节点总数就是平均查找次数
>
>   ###### ![img](https://static.dingtalk.com/media/lALPDgQ9rxMwQXjNATjNArw_700_312.png?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222463521224164%22%7D&bizType=im&open_id=742721380)
>
>   
>
>   可知应该根据节点数量将节点少的接在节点数量多得树下面
>
>   例：分别写出下面用Quick-Union和Weighted Quick-Union得到的数组最终结果
>
>   ![img](https://static.dingtalk.com/media/lALPDgQ9rxNB0vdgzQNk_868_96.png?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222453665810180%22%7D&bizType=im&open_id=742721380)
>
>   ![img](https://static.dingtalk.com/media/lALPDgQ9rxNRp17M-s0E5Q_1253_250.png?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222453665939911%22%7D&bizType=im&open_id=742721380)
>
>   
>
>   ###### ![图片](https://static.dingtalk.com/media/lALPDgQ9rxNRp_HNAhfNBKQ_1188_535.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222453665981181%22%7D&bizType=im&open_id=742721380)
>
>   

```c
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct UnionSet {
    int *father, *size;
    int n;
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet));
    u->father = (int *)malloc(sizeof(int) * (n + 1));
    u->size = (int *)malloc(sizeof(int) * (n + 1));
    u->n = n;
    for (int i = 1; i <= n; i++) {
        u->father[i] = i;
        u->size[i] = 1;
    }
    return u;
}

int find(UnionSet *u, int x) {
  	if(u->father[x] == x) return x;
  	return find(u, u->father[x]);
}

int merge(UnionSet *u, int a, int b) {
    int fa = find(u, a), fb = find(u, b);
    if (fa == fb) return 0;
    if (u->size[fa] < u->size[fb]) swap(fa, fb);
    u->father[fb] = fa;
    u->size[fa] += u->size[fb];
    return 1;
}
```



### Weighted Quick-Union With Path Compression

>   将所有点都指向它最终的根结点(它所在集合的代表元素)就是路径压缩，如上右图的0指向3

```c
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct UnionSet {
    int *father, *size;
    int n;
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet));
    u->father = (int *)malloc(sizeof(int) * (n + 1));
    u->size = (int *)malloc(sizeof(int) * (n + 1));
    u->n = n;
    for (int i = 1; i <= n; i++) {
        u->father[i] = i;
        //u->size[i] = 1;
    }
    return u;
}

int find(UnionSet *u, int x) {
    return u->father[x] = (u->father[x] == x ? x : find(u, u->father[x]));
}

int merge(UnionSet *u, int a, int b) {
    int fa = find(u, a), fb = find(u, b);
    if (fa == fb) return 0;
    //if (u->size[fa] < u->size[fb]) swap(fa, fb);
    u->father[fb] = fa;
    //u->size[fa] += u->size[fb];
    return 1;
}
```



### 复杂度比较

![img](https://static.dingtalk.com/media/lALPDgQ9rxNg9krNAUPNBbY_1462_323.png?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%224248001%3A742721380%22%2C%22msgId%22%3A%222463713273714%22%7D&bizType=im&open_id=742721380)







~~~c
#include <stdio.h>
#include <stdlib.h>

typedef struct DisjointSet{
    int *father, *rank;
} DisjointSet;

void init(DisjointSet *s, int size) {
    s->father = (int *)malloc(sizeof(int) * size);
    s->rank = (int *)malloc(sizeof(int) * size);
    for (int i = 0; i < size; ++i) {
        s->father[i] = i;
        s->rank[i] = 1;
    }
}

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int max(int a, int b) {
    return a > b ? a : b;
}

int find_set(DisjointSet *s, int node) {
    if (s->father[node] != node) {
        s->father[node] = find_set(s, s->father[node]);
    }
    return s->father[node];
}

int merge(DisjointSet *s, int node1, int node2) {
    int ancestor1 = find_set(s, node1);
    int ancestor2 = find_set(s, node2);
    if (ancestor1 != ancestor2) {
    	if (s->rank[ancestor1] > s->rank[ancestor2]) {
            swap(&ancestor1, &ancestor2);
        }
        s->father[ancestor1] = ancestor2;
        s->rank[ancestor2] = max(s->rank[ancestor2], s->rank[ancestor1] + 1);
        return 1;
    }
    return 0;
}

void clear(DisjointSet *s) {
    free(s->father);
    free(s->rank);
    free(s);
}

int main() {
    DisjointSet *dsu = (DisjointSet *)malloc(sizeof(DisjointSet));
    init(dsu, 100);
    int m, x, y;
    scanf("%d", &m);
    for (int i = 0; i < m; ++i) {
        scanf("%d%d", &x, &y);
        int ans = merge(dsu, x, y);
        if (ans) {
            printf("success\n");
        } else {
            printf("failed\n");
        }
    }
    clear(dsu);
    return 0;
}
~~~









~~~c
#include <stdio.h>
#include <stdlib.h>

typedef struct DisjointSet {
    int *father, *rank;
}DisjointSet;

void init(DisjointSet *s, int size) {
    s->father = (int *)malloc(sizeof(int) * size);
    s->rank = (int *)malloc(sizeof(int) * size);
    for (int i = 0; i < size; ++i) {
        s->father[i] = i;
        s->rank[i] = 1;
    }
}

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int max(int a, int b) {
    return a > b ? a : b;
}

int find_set(DisjointSet *s, int node) {
    return s->father[node];
}

int merge(DisjointSet *s, int node1, int node2) {
    int ancestor1 = find_set(s, node1);
    int ancestor2 = find_set(s, node2);
   
    if (ancestor1 != ancestor2) {
    	if (s->rank[ancestor1] > s->rank[ancestor2]) {
            swap(&ancestor1, &ancestor2);
        }
        s->father[ancestor1] = ancestor2;
        s->rank[ancestor2] = max(s->rank[ancestor2], s->rank[ancestor1] + 1);
        //s->rank[ancestor2] += s->rank[ancestor1];
        return 1;
    }
    return 0;
}

void clear(DisjointSet *s) {
    free(s->father);
    free(s->rank);
    free(s);
}

int main() {
    int m, n;
    DisjointSet *s = (DisjointSet *)malloc(sizeof(DisjointSet));
    scanf("%d %d", &m, &n);
    init(s, m);
    int a, b;
    for(int i = 0; i < n; i++) {
        scanf("%d%d", &a, &b);
        merge(s, a, b);
    }
    for(int i = 0; i < m; i++) {
        printf("%d\n", find_set(s, i));
    }
    return 0;
}
~~~













